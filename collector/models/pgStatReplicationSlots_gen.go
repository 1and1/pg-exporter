/*generated by binding gen*/
package models

import (
	"github.com/prometheus/client_golang/prometheus"
)

type PgStatReplicationSlotsSlice []PgStatReplicationSlots

func (r PgStatReplicationSlotsSlice) ToMetrics(namespace string, subsystem string, ch chan<- prometheus.Metric, labelsKV ...string) error {
	for _, row := range []PgStatReplicationSlots(r) {
		if err := row.ToMetrics(namespace, subsystem, ch, labelsKV...); err != nil {
			return err
		}
	}
	return nil
}

func (r *PgStatReplicationSlots) ToMetrics(namespace string, subsystem string, ch chan<- prometheus.Metric, labelsKV ...string) error {
	labels := newLabels(labelsKV...)
	// labels
	labels["slot_name"] = r.SlotName

	// optional labels

	// metrics
	// spill_txns (CounterValue)
	spillTxns := float64(r.SpillTxns)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `spill_txns`), `Number of transactions spilled to disk once the memory used by logical decoding to decode changes from WAL has exceeded logical_decoding_work_mem`, nil, labels,
		), prometheus.CounterValue, spillTxns,
	)

	// spill_count (CounterValue)
	spillCount := float64(r.SpillCount)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `spill_count`), `Number of times transactions were spilled to disk while decoding changes from WAL for this slot`, nil, labels,
		), prometheus.CounterValue, spillCount,
	)

	// spill_bytes (CounterValue)
	spillBytes := float64(r.SpillBytes)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `spill_bytes`), `Amount of decoded transaction data spilled to disk while performing decoding of changes from WAL for this slot`, nil, labels,
		), prometheus.CounterValue, spillBytes,
	)

	// stream_txns (CounterValue)
	streamTxns := float64(r.StreamTxns)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `stream_txns`), `Number of in-progress transactions streamed to the decoding output plugin after the memory used by logical decoding to decode changes from WAL for this slot has exceeded logical_decoding_work_mem`, nil, labels,
		), prometheus.CounterValue, streamTxns,
	)

	// stream_count (CounterValue)
	streamCount := float64(r.StreamCount)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `stream_count`), `Number of times in-progress transactions were streamed to the decoding output plugin while decoding changes from WAL for this slot`, nil, labels,
		), prometheus.CounterValue, streamCount,
	)

	// stream_bytes (CounterValue)
	streamBytes := float64(r.StreamBytes)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `stream_bytes`), `Amount of transaction data decoded for streaming in-progress transactions to the decoding output plugin while decoding changes from WAL for this slot`, nil, labels,
		), prometheus.CounterValue, streamBytes,
	)

	// total_txns (CounterValue)
	totalTxns := float64(r.TotalTxns)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `total_txns`), `Number of decoded transactions sent to the decoding output plugin for this slot`, nil, labels,
		), prometheus.CounterValue, totalTxns,
	)

	// total_bytes (CounterValue)
	totalBytes := float64(r.TotalBytes)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `total_bytes`), `Amount of transaction data decoded for sending transactions to the decoding output plugin while decoding changes from WAL for this slot`, nil, labels,
		), prometheus.CounterValue, totalBytes,
	)

	// stats_reset (CounterValue)
	var statsReset float64
	if r.StatsReset.IsZero() {
		statsReset = float64(0)
	} else {
		statsReset = float64(r.StatsReset.Unix())
	}
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `stats_reset`), `Time at which these statistics were last reset`, nil, labels,
		), prometheus.CounterValue, statsReset,
	)

	// optional metrics

	return nil
}
